#region Using Directives

using System;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Resources;
using System.Text;
using System.Web;
using System.Web.Services.Description;
using System.Web.Services.Protocols;
using System.Xml;
using System.Xml.Schema;
using System.Xml.XPath;

#endregion

namespace Loom.Web.Services
{
    /// <summary>
    ///     ValidationExtension implements both schema validation and assertion processing
    /// </summary>
    public class ValidationExtension : SoapExtension
    {
        /// <summary>
        ///     initializer object (context for each request)
        ///     generated by GetInitializer
        /// </summary>
        private ValidationContext context;

        /// <summary>
        ///     used to hold memory stream that is used when
        ///     client side processing of message is done. The
        ///     memory stream is passed back by ChainStream to
        ///     capture the message generated by the proxy
        ///     so it can be validated
        /// </summary>
        internal Stream Filter;

        /// <summary>
        ///     used to hold actual request stream from
        ///     proxy. Data sent to this stream is sent to
        ///     the web service. Used in client(proxy) side
        ///     processing to hold the stream passed in
        ///     by ChainStream. After successful validation
        ///     MemoryStream is copied to Request
        /// </summary>
        internal Stream Request;

        /// <summary>
        ///     SerializationPass initialized then later
        ///     moved through states as ChainStream is called
        /// </summary>
        internal SerializationPass SerializationPass = SerializationPass.None;

        /// <summary>
        ///     used to read an XML Schema from a file
        /// </summary>
        /// <param name="schemaCollection">Container for schemas later used to validate message</param>
        /// <param name="filePath">
        ///     path to a file that contains a schema.
        ///     Note that appropriate file permissions are required for this to work.
        /// </param>
        private static void LoadSchemaFromFile(XmlSchemaSet schemaCollection, string filePath)
        {
            Argument.Assert.IsNotNull(schemaCollection, "schemaCollection");
            Argument.Assert.IsNotNull(filePath, "filePath");
            Argument.Assert.FileExists(filePath);

            XmlTextReader schemaReader = new XmlTextReader(filePath);
            XmlSchema schema = XmlSchema.Read(schemaReader, null);
            schemaCollection.Add(schema);
        }

        /// <summary>
        ///     Retrives schemas from wsdl file for
        ///     web service. Used only on web service, not proxy
        /// </summary>
        /// <param name="schemaCollection">Container for schemas later used to validate message</param>
        /// <param name="serviceDescription">An object which, in effect, contains the wsdl file</param>
        private static void LoadSchemasFromServiceDescriptions(XmlSchemaSet schemaCollection, ServiceDescription serviceDescription)
        {
            Argument.Assert.IsNotNull(serviceDescription, "serviceDescription");
            Argument.Assert.IsNotNull(schemaCollection, "schemaCollection");

            foreach (XmlSchema embeddedXsd in serviceDescription.Types.Schemas)
                schemaCollection.Add(embeddedXsd);
        }

        /// <summary>
        ///     Loads schemas from directories relative to web service. Used only on
        ///     web service, not proxy.
        /// </summary>
        /// <param name="schemaCollection">Container for schemas later used to validate message</param>
        /// <param name="relativeDir">
        ///     Directory, relative to web service. Schemas from files with ".xsd" or
        ///     ".wsdl" extension are added to XmlSchemaCollection
        /// </param>
        private static void LoadSchemasFromDirectory(XmlSchemaSet schemaCollection, string relativeDir)
        {
            if (Directory.Exists(HttpContext.Current.Server.MapPath(relativeDir)))
            {
                string[] schemaFiles = Directory.GetFiles(HttpContext.Current.Server.MapPath(relativeDir), "*.xsd");
                foreach (string schemaFile in schemaFiles)
                    LoadSchemaFromFile(schemaCollection, schemaFile);
                string[] wsdlFiles = Directory.GetFiles(HttpContext.Current.Server.MapPath(relativeDir), "*.wsdl");
                foreach (string wsdlFile in wsdlFiles)
                {
                    ServiceDescription sd = ServiceDescription.Read(wsdlFile);
                    LoadSchemasFromServiceDescriptions(schemaCollection, sd);
                }
            }
        }

        /// <summary>
        ///     Loads schemas that are defined for the web service. Used only on
        ///     web service, not on client(proxy).
        /// </summary>
        /// <param name="schemaCollection">Container for schemas later used to validate message</param>
        /// <param name="type">web service type</param>
        /// <param name="url">url of service</param>
        private static void LoadReflectedSchemas(XmlSchemaSet schemaCollection, Type type, string url)
        {
            Argument.Assert.IsNotNull(schemaCollection, "schemaCollection");
            Argument.Assert.IsNotNull(type, "type");
            Argument.Assert.IsNotNull(url, "url");

            ServiceDescriptionReflector r = new ServiceDescriptionReflector();

            r.Reflect(type, url);
            foreach (XmlSchema xsd in r.Schemas)
                schemaCollection.Add(xsd);
            foreach (ServiceDescription sd in r.ServiceDescriptions)
                LoadSchemasFromServiceDescriptions(schemaCollection, sd);
        }

        /// <summary>
        ///     Used to load schema that is embeded in an assembly as a resource. Used on web service only,
        ///     not on client(proxy)
        /// </summary>
        /// <param name="schemaCollection">Container for schemas later used to validate message</param>
        /// <param name="root">Name set of resources required from assembly</param>
        /// <param name="assemblyName">
        ///     Name of assembly. Note that
        ///     this should be full name of assembly.
        /// </param>
        /// <param name="resourceName">
        ///     Name of specific resource required. This is used, for example, to
        ///     get the SOAP 1.1 schema that is in the assembly for the soap extension
        /// </param>
        private static void LoadSchemaFromResourceFile(XmlSchemaSet schemaCollection, string root, string assemblyName, string resourceName)
        {
            Argument.Assert.IsNotNull(schemaCollection, "schemaCollection");
            Argument.Assert.IsNotNull(root, "root");
            Argument.Assert.IsNotNull(assemblyName, "assemblyName");
            Argument.Assert.IsNotNull(resourceName, "resourceName");

            // load SOAP 1.1 schema from assembly resource file		
            ResourceManager resmgr = new ResourceManager(root, Assembly.Load(assemblyName));
            //System.Reflection.Assembly.GetExecutingAssembly());
            string resSchema = resmgr.GetString(resourceName);
            StringReader sreader = new StringReader(resSchema);
            XmlTextReader xtr = new XmlTextReader(sreader);
            XmlSchema soapSchema = XmlSchema.Read(xtr, null);
            schemaCollection.Add(soapSchema);
            xtr.Close();
        }

        /// <summary>
        ///     Used to get the initializer object for SOAP extension when
        ///     it is being used on the web service.
        /// </summary>
        /// <param name="serviceType">Web service</param>
        /// <param name="methodInfo">Method being processed, if there is one</param>
        /// <param name="attribute">Attribute being processed</param>
        /// <returns>Object that will be passed to code that processes web method invocations</returns>
        private static object GetInitializerHelper(Type serviceType, LogicalMethodInfo methodInfo, SoapExtensionAttribute attribute)
        {
            ValidationContext validationContext = new ValidationContext();
            // cache ValidationAttribute for future use
            validationContext.ValidationAttribute = (ValidationAttribute) attribute;

            // temporary document/navigator for compiling XPath expressions
            XmlDocument doc = new XmlDocument();
            XPathNavigator nav = doc.CreateNavigator();
            // namespace manager for holding all namespace bindings
            XmlNamespaceManager namespaceManager = new XmlNamespaceManager(nav.NameTable);

            // retrieve (user-provided) namespace binding attributes
            object[] namespaceAtts = serviceType.GetCustomAttributes(typeof(AssertNamespaceBindingAttribute), true);
            foreach (AssertNamespaceBindingAttribute bindingAttribute in namespaceAtts)
                namespaceManager.AddNamespace(bindingAttribute.Prefix, bindingAttribute.Namespace);
            // store namespace manager in context for future use
            validationContext.NamespaceManager = namespaceManager;

            // retrieve (user-provided) assertion attributes
            AssertAttribute[] allRuleAtts;
            object[] classRuleAtts = serviceType.GetCustomAttributes(typeof(AssertAttribute), true);
            if (methodInfo != null) // enabled via custom SoapExtensionAttribute
            {
                // retrieve (user-provided) method and class-level assert attributes
                object[] methodRuleAtts = methodInfo.GetCustomAttributes(typeof(AssertAttribute));
                allRuleAtts = new AssertAttribute[methodRuleAtts.Length + classRuleAtts.Length];
                methodRuleAtts.CopyTo(allRuleAtts, 0);
                classRuleAtts.CopyTo(allRuleAtts, methodRuleAtts.Length);
            }
            else
            {
                // just retrieve (user-provided) class-level assertion attributes
                allRuleAtts = (AssertAttribute[]) classRuleAtts;
            }

            // store all assertions in context
            validationContext.AssertAttributes = allRuleAtts;

            // generate, compile, and cache XPath expressions for future use
            StringBuilder completeExpression = new StringBuilder();
            string and = string.Empty;
            foreach (AssertAttribute assertAttribute in allRuleAtts)
            {
                string rule = string.Format("boolean({0})", assertAttribute.Rule);
                // cache compiled expression for future use
                assertAttribute.Expression = nav.Compile(rule);
                assertAttribute.Expression.SetContext(namespaceManager);
                completeExpression.Append(and);
                completeExpression.Append(rule);
                and = " and ";
            }
            if (completeExpression.Length != 0)
            {
                // complete expression (combination off all asserts) for quick success/failure check
                validationContext.CompleteRuleExpression = nav.Compile(completeExpression.ToString());
                validationContext.CompleteRuleExpression.SetContext(namespaceManager);
            }
            if (validationContext.ValidationAttribute.SchemaValidation)
            {
                // XML Schema cache for schema validation
                XmlSchemaSet xmlSchemaCollection = new XmlSchemaSet();

                // load SOAP 1.1 schema from assembly resource file
                LoadSchemaFromResourceFile(xmlSchemaCollection, "Resources.ValidationResources",
                    Assembly.GetExecutingAssembly().FullName,
                    "SOAP1.1");
                if (validationContext.CurrentEndpoint == Endpoint.Server)
                {
                    // load from xsd directory by default
                    LoadSchemasFromDirectory(xmlSchemaCollection, "xsd");
                    // load automatically-generated XML Schema for current endpoint (in case it hasn't already been loaded)
                    LoadReflectedSchemas(xmlSchemaCollection, serviceType, HttpContext.Current.Request.RawUrl);
                }
                else
                {
                    // on client side schemas are embeded as attributes
                    object[] schemaAtts = serviceType.GetCustomAttributes(typeof(ValidationSchemaValueAttribute), true);
                    foreach (ValidationSchemaValueAttribute schema in schemaAtts)
                        xmlSchemaCollection.Add(schema.Schema);
                }
                // load schemas from user-defined vroot caches
                object[] schemaCacheAtts = serviceType.GetCustomAttributes(typeof(ValidationSchemaCacheAttribute), true);
                if (schemaCacheAtts.Length == 0)
                    foreach (ValidationSchemaCacheAttribute schemaCacheLoc in schemaCacheAtts)
                        LoadSchemasFromDirectory(xmlSchemaCollection, schemaCacheLoc.RelativeDirectory);

                // load schemas from explicit (user-provided) locations
                object[] schemaLocations = serviceType.GetCustomAttributes(typeof(ValidationSchemaAttribute), true);
                foreach (ValidationSchemaAttribute validationSchemaAttribute in schemaLocations)
                    LoadSchemaFromFile(xmlSchemaCollection, HttpContext.Current.Server.MapPath(validationSchemaAttribute.Location));

                // save schema cache for future use
                validationContext.SchemaCollection = xmlSchemaCollection;
            }
            // the System.Web.Services infrastructure will cache this object
            // and supply it in each future call to Initialize
            return validationContext;
        }

        /// <summary>
        ///     this GetInitializer is called when the SoapExtension is registered
        ///     in the config file (web/machine.config), it's called the first time
        ///     the class is invoked
        /// </summary>
        /// <param name="serviceType">Web service</param>
        /// <returns>Object that will be passed to code that processes web method invocations</returns>
        public override object GetInitializer(Type serviceType)
        {
            Argument.Assert.IsNotNull(serviceType, "serviceType");

            ValidationContext validationContext = new ValidationContext();
            validationContext.ClassContext = true;
            return validationContext;
        }

        /// <summary>
        ///     Used to get the initializer object for SOAP extension that
        ///     is configured for entire web serice.
        /// </summary>
        /// <param name="methodInfo">Method being processed, if there is one</param>
        /// <param name="attribute">Attribute being processed</param>
        /// <returns>Object that will be passed to code that processes web method invocations</returns>
        public override object GetInitializer(LogicalMethodInfo methodInfo, SoapExtensionAttribute attribute)
        {
            Argument.Assert.IsNotNull(methodInfo, "methodInfo");
            Argument.Assert.IsNotNull(attribute, "attribute");

            return GetInitializerHelper(methodInfo.DeclaringType, methodInfo, attribute);
        }

        /// <summary>
        ///     called whenever each a given [WebMethod] is used (will recieve a ValidationContext object)
        /// </summary>
        /// <param name="initializer">Object was created when first web method was called</param>
        public override void Initialize(object initializer)
        {
            // no state needs to be saved for a class attribute, it
            // is all aggrated into the Initialize for the method.
            // You must create an initialize so that the ProcessMethod
            // will know that is is being called for the class Initializer 
            // object
            context = (ValidationContext) initializer;
        }

        /// <summary>
        ///     Used to throw SoapException when the
        ///     content of the method in valid according
        ///     to the schema
        /// </summary>
        private void ThrowSchemaError()
        {
            // throw soap exception that indicates schema failure
            // make an error doc to hold detail element for schema
            XmlDocument errorDoc = new XmlDocument();
            // create a detail element for the
            // error message
            XmlElement detailElement =
                errorDoc.CreateElement(
                    // use DetailElementName and Namespace to insure
                    // that detail element has proper name
                    SoapException.DetailElementName.Name,
                    SoapException.DetailElementName.Namespace);
            // make the detail element the root of the error document
            errorDoc.AppendChild(detailElement);
            // make an element that specifies that a validation
            // error has occured
            XmlElement failedRulesElement =
                errorDoc.CreateElement("dm", "failedValidation", ValidationNamespaces.DevInterop);
            // make this element a child of the detail element
            detailElement.AppendChild(failedRulesElement);
            // create an actor string that indicates where
            // the error was detected
            string actor = context.CurrentEndpoint == Endpoint.Server ? HttpContext.Current.Request.Url.AbsoluteUri : "urn:ClientSide";
            // throw soap exception
            // this will be returned as a soap
            // error message
            throw new SoapException(
                "Failed schema validation",
                SoapException.ClientFaultCode,
                actor,
                detailElement);
        }

        /// <summary>
        ///     this will be called four times (before/after serialize/deserialize) for each [WebMethod]
        /// </summary>
        /// <param name="message">Message being processed</param>
        public override void ProcessMessage(SoapMessage message)
        {
            Argument.Assert.IsNotNull(message, "message");

            if (context.ClassContext)
                return;

            // this extension only cares about the BeforeSerialize stage where it
            Trace.WriteLine("process message");
            // performs schema/assertion validation
            SoapMessageStage checkStage = context.CurrentEndpoint == Endpoint.Server ? SoapMessageStage.BeforeDeserialize : SoapMessageStage.AfterSerialize;
            if (checkStage == message.Stage && context != null)
            {
                Trace.WriteLine("Stage check");
                Stream useStream = message.Stream;
                if (context.CurrentEndpoint == Endpoint.Client)
                    useStream = Filter;
                long streamPosition = useStream.Position;
                try
                {
                    useStream.Position = 0L;
                    // create an XPathNavigator on the request stream
                    XmlReader reader;
                    // check to see if the user wants schema validation
                    if (context.ValidationAttribute != null &&
                        context.ValidationAttribute.SchemaValidation)
                    {
                        // this message should be schema validated so
                        // configure XmlValidatingReader
                        // add specified schemas, including the ones from the WSDL file
                        XmlReaderSettings settings = new XmlReaderSettings();
                        // add the schemas specified by 
                        settings.ValidationType = ValidationType.Schema;
                        settings.ValidationFlags |= XmlSchemaValidationFlags.ProcessInlineSchema;
                        settings.ValidationFlags |= XmlSchemaValidationFlags.ReportValidationWarnings;
                        settings.Schemas.Add(context.SchemaCollection);
                        XmlReader xmlValidatingReader = XmlReader.Create(useStream, settings);
                        if (context.ValidationAttribute.CheckAssertions == false)
                            try
                            {
                                // read through the stream,
                                // if something in it does not
                                // comply with the schemas it
                                // will through an exception
                                //AssertNamespaceBindingAttribute
                                while (xmlValidatingReader.Read()) { } // read through stream
                            }
                            catch (Exception)
                            {
                                ThrowSchemaError();
                            }
                        reader = xmlValidatingReader;
                    }
                    else
                    {
                        // if we get to here then no schema validation
                        // was require, just make a reader that
                        // can be used to evaluate xpath expressions
                        reader = new XmlTextReader(useStream);
                    }
                    // evaluate the XPath assertions - if complete expression returns true
                    // let the System.Web.Services infrastructure finish processing 
                    if (context.ValidationAttribute != null &&
                        context.ValidationAttribute.CheckAssertions)
                    {
                        Trace.WriteLine("validate");
                        // turn the message stream into an XPathDocument
                        XPathDocument doc = new XPathDocument(reader);
                        // get an navigator from the docuement
                        XPathNavigator nav = doc.CreateNavigator();

                        if (context.ValidationAttribute.SchemaValidation)
                            Trace.WriteLine("Schema Check");
                        if (context.CompleteRuleExpression != null &&
                            false == (bool) nav.Evaluate(context.CompleteRuleExpression))
                        {
                            // otherwise generate a SOAP fault indicating exactly which
                            // assertions failed
                            // make a document to construct a detail element
                            XmlDocument errorDoc = new XmlDocument();
                            // make a detail element
                            XmlElement detailElement =
                                errorDoc.CreateElement(
                                    SoapException.DetailElementName.Name,
                                    SoapException.DetailElementName.Namespace);
                            // make it the root of the document
                            errorDoc.AppendChild(detailElement);
                            // make an element that indicates that assertions failed
                            XmlElement failedRulesElement =
                                errorDoc.CreateElement("dm", "failedAssertions", ValidationNamespaces.DevInterop);
                            // add the failure elememt to the detail
                            detailElement.AppendChild(failedRulesElement);
                            // generate namespace declarations required by assert expressions
                            foreach (string prefix in context.NamespaceManager)
                            {
                                if (prefix.Equals("xml") || prefix.Equals("xmlns") || prefix.Length == 0)
                                    continue;
                                XmlAttribute nsDeclAttribute = errorDoc.CreateAttribute("xmlns", prefix, ValidationNamespaces.XmlNamespace);
                                nsDeclAttribute.Value = context.NamespaceManager.LookupNamespace(prefix);
                                failedRulesElement.Attributes.Append(nsDeclAttribute);
                            }

                            // check to see which assertions failed and list in failedRules
                            foreach (AssertAttribute assertAttribute in context.AssertAttributes)
                                // check the current assertion
                                if (false == (bool) nav.Evaluate(assertAttribute.Expression))
                                {
                                    // it faild, make an element that indicates this
                                    XmlElement assertElement = errorDoc.CreateElement("dm", "assert", ValidationNamespaces.DevInterop);
                                    failedRulesElement.AppendChild(assertElement);
                                    // make an element that will hold the xpath expression that failed
                                    XmlElement expElement = errorDoc.CreateElement("dm", "expression", ValidationNamespaces.DevInterop);
                                    assertElement.AppendChild(expElement);
                                    expElement.InnerText = assertAttribute.Rule;
                                    // make an element that holds the error expression
                                    // associated with the xpath expression business rule
                                    XmlElement descElement = errorDoc.CreateElement("dm", "description", ValidationNamespaces.DevInterop);
                                    assertElement.AppendChild(descElement);
                                    descElement.InnerText = assertAttribute.Description;
                                }

                            reader.Close();
                            // make an actor string to indicate
                            // where error was detected
                            string actor = context.CurrentEndpoint == Endpoint.Server ? HttpContext.Current.Request.Url.AbsoluteUri : "urn:ClientSide";
                            // throw soap excetion that describes error
                            // this will be returned as soap error message
                            throw new SoapException(
                                "Business rules failed validation",
                                SoapException.ClientFaultCode,
                                actor,
                                detailElement);
                        }

                        // message was validated and produced no assertion
                        if (context.CurrentEndpoint == Endpoint.Client)
                        {
                            // if we got this and this is the client then
                            // push the filer to the server
                            Filter.Position = 0L;
                            byte[] buffer = new byte[1024];
                            int read;
                            while ((read = Filter.Read(buffer, 0, buffer.Length)) > 0)
                                Request.Write(buffer, 0, read);
                            Request.Close();
                        }
                    }
                }
                catch (SoapException)
                {
                    // if you get to here you are catching
                    // the SoapException thrown by the assertion
                    // check, so just rethrow it.
                    throw;
                }
                catch (Exception)
                {
                    // if you get to here then the 
                    // schema validator threw the exception,
                    // turn it into a SoapException
                    ThrowSchemaError();
                }
                finally
                {
                    // make sure you leave the stream the way you found it
                    if (context.CurrentEndpoint != Endpoint.Client)
                        useStream.Position = streamPosition;
                }
            }
        }

        /// <summary>
        ///     This is called by the SOAP extension framework. It allows low level
        ///     access to the stream the represents a message being sent/received by a
        ///     web service/client.
        /// </summary>
        /// <param name="stream">Stream from SOAP extension framework</param>
        /// <returns>
        ///     stream passed back to SOAP extension framework. The framework
        ///     will used this stream for processing.
        /// </returns>
        public override Stream ChainStream(Stream stream)
        {
            Argument.Assert.IsNotNull(stream, "stream");

            Stream retValue = stream;
            if (null == HttpContext.Current)
            {
                // this is the processing done on the 
                // client side
                switch (SerializationPass)
                {
                    case SerializationPass.None:
                        SerializationPass = SerializationPass.Serialize;
                        break;

                    case SerializationPass.Serialize:
                        SerializationPass = SerializationPass.Deserialize;
                        break;
                }
                if (SerializationPass == SerializationPass.Serialize)
                {
                    retValue = Filter = new MemoryStream();
                    // remember the the request stream for later
                    // you will use it to send the request to the
                    // server if the message is valid
                    Request = stream;
                }
            }
            else
            {
                // on the server side just use
                // the stream as is
                base.ChainStream(stream);
            }
            return retValue;
        }
    }
}